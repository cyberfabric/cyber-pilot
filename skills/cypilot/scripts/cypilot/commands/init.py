import argparse
import json
import os
import re
import shutil
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from ..utils.artifacts_meta import create_backup, generate_default_registry, generate_slug
from ..utils.files import find_project_root
from ..utils import toml_utils

# Directories to copy from cache into project cypilot/.core/ dir
COPY_DIRS = ["kits", "architecture", "requirements", "schemas", "workflows", "skills"]
COPY_ROOT_DIRS: list[str] = []
CACHE_DIR = Path.home() / ".cypilot" / "cache"
CORE_SUBDIR = ".core"
GEN_SUBDIR = ".gen"
DEFAULT_INSTALL_DIR = "cypilot"


def _copy_from_cache(cache_dir: Path, target_dir: Path, force: bool = False) -> Dict[str, str]:
    """Copy tool directories from cache into project cypilot/.core/ dir.

    Core directories go into .core/ (read-only reference content).
    User-editable content lives in config/.

    Returns dict of {dir_name: action} where action is 'created', 'updated', or 'skipped'.
    """
    core_dir = target_dir / CORE_SUBDIR
    core_dir.mkdir(parents=True, exist_ok=True)
    results: Dict[str, str] = {}

    def _copy_one(src: Path, dst: Path, name: str) -> None:
        if not src.is_dir():
            results[name] = "missing_in_cache"
            return
        if dst.exists():
            if not force:
                results[name] = "skipped"
                return
            shutil.rmtree(dst)
            results[name] = "updated"
        else:
            results[name] = "created"
        shutil.copytree(src, dst)

    for name in COPY_DIRS:
        _copy_one(cache_dir / name, core_dir / name, name)

    for name in COPY_ROOT_DIRS:
        _copy_one(cache_dir / name, target_dir / name, name)

    return results


def _core_readme() -> str:
    """README.md content for .core/ directory."""
    return (
        "# .core — Cypilot Core Files\n"
        "\n"
        "**Do NOT edit files in this directory.**\n"
        "\n"
        "These files are copied from the Cypilot cache (`~/.cypilot/cache/`) during\n"
        "`cpt init` or `cpt kit install`. They are the read-only reference copies of:\n"
        "\n"
        "- `kits/` — kit definitions (blueprints, constraints, artifacts)\n"
        "- `skills/` — Cypilot skill scripts and CLI entry points\n"
        "- `architecture/` — architecture specs and feature documents\n"
        "- `requirements/` — validation requirements\n"
        "- `schemas/` — JSON schemas for configuration files\n"
        "- `workflows/` — workflow definitions\n"
        "\n"
        "To update these files, run `cpt init --force` or `cpt kit update`.\n"
        "Any manual changes **will be overwritten** on the next update.\n"
    )


def _gen_readme() -> str:
    """README.md content for .gen/ directory."""
    return (
        "# .gen — Generated Files\n"
        "\n"
        "**Do NOT edit files in this directory.**\n"
        "\n"
        "These files are auto-generated by Cypilot from kit blueprints during\n"
        "`cpt init`, `cpt kit install`, or `cpt generate-resources`.\n"
        "\n"
        "Contents:\n"
        "\n"
        "- `SKILL.md` — aggregated skill navigation (routes to per-kit skills)\n"
        "- `AGENTS.md` — generated agent navigation rules\n"
        "- `kits/{slug}/SKILL.md` — per-kit skill instructions from `@cpt:skill` blocks\n"
        "- `kits/{slug}/artifacts/{KIND}/` — generated templates, rules, checklists, examples\n"
        "- `kits/{slug}/constraints.toml` — structural constraints from `@cpt:heading`/`@cpt:id`\n"
        "\n"
        "Source of truth: blueprints in `config/kits/{slug}/blueprints/`.\n"
        "To regenerate: `cpt generate-resources`.\n"
        "Any manual changes **will be overwritten** on the next generation.\n"
    )


def _config_readme() -> str:
    """README.md content for config/ directory."""
    return (
        "# config — User Configuration\n"
        "\n"
        "This directory contains **user-editable** configuration files.\n"
        "\n"
        "## Files\n"
        "\n"
        "- `core.toml` — project settings (system name, slug, kit references)\n"
        "- `artifacts.toml` — artifacts registry (systems, ignore patterns)\n"
        "- `AGENTS.md` — custom agent navigation rules (add your own WHEN rules here)\n"
        "- `SKILL.md` — custom skill extensions (add your own skill instructions here)\n"
        "\n"
        "## Directories\n"
        "\n"
        "- `kits/{slug}/blueprints/` — editable copies of kit blueprints.\n"
        "  Modify these to customize generated artifacts, then run `cpt generate-resources`.\n"
        "\n"
        "## Tips\n"
        "\n"
        "- `AGENTS.md` and `SKILL.md` start empty. Add any project-specific rules or\n"
        "  skill instructions here — they will be picked up alongside the generated ones.\n"
        "- Changes to blueprints take effect after running `cpt generate-resources`.\n"
    )


def _default_core_toml(system_name: str, system_slug: str) -> dict:
    """Build default core.toml data for a new project."""
    return {
        "version": "1.0",
        "project_root": "..",
        "system": {
            "name": system_name,
            "slug": system_slug,
            "kit": "cypilot-sdlc",
        },
        "kits": {
            "cypilot-sdlc": {
                "format": "Cypilot",
                "path": ".gen/kits/sdlc",
            },
        },
    }


def _prompt_path(question: str, default: Optional[str]) -> str:
    prompt = f"{question}"
    if default is not None and str(default).strip():
        prompt += f" [{default}]"
    prompt += ": "
    try:
        sys.stderr.write(prompt)
        sys.stderr.flush()
        ans = input().strip()
    except EOFError:
        ans = ""
    if ans:
        return ans
    return default or ""


def _resolve_user_path(raw: str, base: Path) -> Path:
    p = Path(raw)
    if not p.is_absolute():
        p = base / p
    return p.resolve()


def _slug_to_pascal_case(slug: str) -> str:
    """Convert a slug like 'my-app' to PascalCase like 'MyApp'."""
    return "".join(word.capitalize() for word in slug.split("-")) if slug else "Unnamed"


def _define_root_system(project_root: Path) -> Dict[str, str]:
    """
    Define root system from project directory.

    Returns dict with 'name' (PascalCase) and 'slug' (lowercase-hyphenated).
    """
    # @cpt-begin:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-extract-basename
    basename = project_root.name
    # @cpt-end:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-extract-basename

    # @cpt-begin:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-derive-slug
    slug = generate_slug(basename)
    # @cpt-end:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-derive-slug

    # @cpt-begin:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-derive-name
    name = _slug_to_pascal_case(slug)
    # @cpt-end:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-derive-name

    # @cpt-begin:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-return-system-def
    return {"name": name, "slug": slug}
    # @cpt-end:cpt-cypilot-algo-core-infra-define-root-system:p1:inst-return-system-def


_TOML_FENCE_RE = re.compile(r"```toml\s*\n(.*?)```", re.DOTALL)
MARKER_START = "<!-- @cpt:root-agents -->"
MARKER_END = "<!-- /@cpt:root-agents -->"


def _read_existing_install(project_root: Path) -> Optional[str]:
    """
    Check if project already has Cypilot installed by reading AGENTS.md TOML block.

    Returns install dir relative path if found, None otherwise.
    """
    import tomllib
    agents_file = project_root / "AGENTS.md"
    if not agents_file.is_file():
        return None
    try:
        content = agents_file.read_text(encoding="utf-8")
    except OSError:
        return None
    if MARKER_START not in content:
        return None
    for m in _TOML_FENCE_RE.finditer(content):
        try:
            data = tomllib.loads(m.group(1))
            val = data.get("cypilot_path") or data.get("cypilot")
            if isinstance(val, str) and val.strip():
                adapter_dir = project_root / val.strip()
                if adapter_dir.is_dir():
                    return val.strip()
        except Exception:
            continue
    return None


def _compute_managed_block(install_dir: str) -> str:
    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-compute-block
    return (
        f"{MARKER_START}\n"
        f"## Cypilot AI Agent Navigation\n"
        f"\n"
        f"**Remember these variables while working in this project:**\n"
        f"\n"
        f"```toml\n"
        f'cypilot_path = "{install_dir}"\n'
        f"```\n"
        f"\n"
        f"## Navigation Rules\n"
        f"\n"
        f"ALWAYS open and follow `{{cypilot_path}}/.gen/AGENTS.md` FIRST\n"
        f"\n"
        f"ALWAYS open and follow `{{cypilot_path}}/config/AGENTS.md` WHEN it exists\n"
        f"\n"
        f"ALWAYS invoke `{{cypilot_path}}/.core/skills/cypilot/SKILL.md` WHEN user asks to do something with Cypilot\n"
        f"\n"
        f"{MARKER_END}"
    )
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-compute-block


def _inject_root_agents(project_root: Path, install_dir: str, dry_run: bool = False) -> str:
    """Inject or update root AGENTS.md managed block. Returns action taken."""
    agents_file = project_root / "AGENTS.md"
    expected_block = _compute_managed_block(install_dir)

    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-if-no-agents
    if not agents_file.is_file():
        # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-create-agents-file
        if not dry_run:
            agents_file.write_text(expected_block + "\n", encoding="utf-8")
        return "created"
        # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-create-agents-file
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-if-no-agents

    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-read-existing
    content = agents_file.read_text(encoding="utf-8")
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-read-existing

    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-if-markers-exist
    if MARKER_START in content and MARKER_END in content:
        start_idx = content.index(MARKER_START)
        end_idx = content.index(MARKER_END) + len(MARKER_END)
        current_block = content[start_idx:end_idx]
        if current_block == expected_block.strip():
            return "unchanged"
        # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-replace-block
        new_content = content[:start_idx] + expected_block + content[end_idx:]
        # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-replace-block
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-if-markers-exist
    else:
        # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-insert-block
        new_content = expected_block + "\n\n" + content
        # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-insert-block

    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-write-agents
    if not dry_run:
        agents_file.write_text(new_content, encoding="utf-8")
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-write-agents

    # @cpt-begin:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-return-agents-path
    return "updated"
    # @cpt-end:cpt-cypilot-algo-core-infra-inject-root-agents:p1:inst-return-agents-path


def cmd_init(argv: List[str]) -> int:
    # @cpt-dod:cpt-cypilot-dod-core-infra-init-config:p1
    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-user-init
    p = argparse.ArgumentParser(prog="init", description="Initialize Cypilot in a project")
    p.add_argument("--project-root", default=None, help="Project root directory")
    p.add_argument("--install-dir", default=None, help="Cypilot directory relative to project root (default: cypilot)")
    p.add_argument("--project-name", default=None, help="Project name (default: project root folder name)")
    p.add_argument("--yes", action="store_true", help="Do not prompt; accept defaults")
    p.add_argument("--dry-run", action="store_true", help="Compute changes without writing files")
    p.add_argument("--force", action="store_true", help="Overwrite existing files")
    args = p.parse_args(argv)
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-user-init

    cwd = Path.cwd().resolve()

    # Resolve project root
    default_project_root = cwd
    if args.project_root is None and not args.yes:
        raw_root = _prompt_path("Project root directory?", default_project_root.as_posix())
        project_root = _resolve_user_path(raw_root, cwd)
    else:
        raw_root = args.project_root or default_project_root.as_posix()
        project_root = _resolve_user_path(raw_root, cwd)

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-check-existing
    existing_install_rel = _read_existing_install(project_root)
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-check-existing

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-if-exists
    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-return-exists
    if existing_install_rel is not None and not args.force:
        print(json.dumps({
            "status": "FAIL",
            "message": "Cypilot already initialized. Use 'cypilot update' to upgrade or --force to reinitialize.",
            "project_root": project_root.as_posix(),
            "cypilot_dir": (project_root / existing_install_rel).as_posix(),
        }, indent=2, ensure_ascii=False))
        return 2
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-return-exists
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-if-exists

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-if-interactive
    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-prompt-dir
    default_install_dir = existing_install_rel or DEFAULT_INSTALL_DIR
    if args.install_dir is None and not args.yes:
        install_rel = _prompt_path("Cypilot directory (relative to project root)?", default_install_dir)
    else:
        install_rel = args.install_dir or default_install_dir
    install_rel = install_rel.strip() or default_install_dir
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-prompt-dir
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-if-interactive

    cypilot_dir = (project_root / install_rel).resolve()

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-define-root
    root_system = _define_root_system(project_root)
    project_name = str(args.project_name).strip() if args.project_name else root_system["name"]
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-define-root

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-prompt-agents
    # Stub: agent selection not yet needed (single kit); will prompt when multi-kit support lands
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-prompt-agents

    # Verify cache exists
    if not CACHE_DIR.is_dir():
        print(json.dumps({
            "status": "ERROR",
            "message": f"Cypilot cache not found at {CACHE_DIR}. Run 'cypilot update' first.",
            "project_root": project_root.as_posix(),
        }, indent=2, ensure_ascii=False))
        return 1

    actions: Dict[str, str] = {}
    errors: List[Dict[str, str]] = []
    backups: List[str] = []

    # Create backup before --force overwrites
    if args.force and cypilot_dir.exists() and not args.dry_run:
        backup_path = create_backup(cypilot_dir)
        if backup_path:
            backups.append(backup_path.as_posix())

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-copy-skill
    if not args.dry_run:
        cypilot_dir.mkdir(parents=True, exist_ok=True)
        copy_results = _copy_from_cache(CACHE_DIR, cypilot_dir, force=args.force)
    else:
        copy_results = {d: "dry_run" for d in COPY_DIRS}
    actions["copy"] = json.dumps(copy_results)
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-copy-skill

    # Create the three subdirectories: .core/ (already created by _copy_from_cache), .gen/, config/
    config_dir = cypilot_dir / "config"
    gen_dir = cypilot_dir / GEN_SUBDIR
    core_dir = cypilot_dir / CORE_SUBDIR
    if not args.dry_run:
        config_dir.mkdir(parents=True, exist_ok=True)
        gen_dir.mkdir(parents=True, exist_ok=True)

    # Write README.md into each directory (always overwrite)
    if not args.dry_run:
        (core_dir / "README.md").write_text(_core_readme(), encoding="utf-8")
        (gen_dir / "README.md").write_text(_gen_readme(), encoding="utf-8")
        (config_dir / "README.md").write_text(_config_readme(), encoding="utf-8")
    actions["readmes"] = "created"

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-create-config
    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config:p1:inst-mkdir-config
    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-gen-when-rules
    kit_id = "cypilot-sdlc"
    artifacts_when = f"ALWAYS open and follow `{{cypilot_path}}/config/artifacts.toml` WHEN Cypilot uses kit `{kit_id}` for artifact kinds: PRD, DESIGN, DECOMPOSITION, ADR, FEATURE OR codebase"
    gen_agents_content = "\n".join([
        f"# Cypilot: {project_name}",
        "",
        "## Navigation Rules",
        "",
        "ALWAYS open and follow `{cypilot_path}/.core/schemas/artifacts.schema.json` WHEN working with artifacts.toml",
        "",
        "ALWAYS open and follow `{cypilot_path}/.core/architecture/specs/artifacts-registry.md` WHEN working with artifacts.toml",
        "",
        artifacts_when,
        "",
    ])
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-gen-when-rules

    desired_registry = generate_default_registry(project_name)

    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config:p1:inst-write-core-toml
    desired_core = _default_core_toml(project_name, root_system["slug"])
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config:p1:inst-write-core-toml
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config:p1:inst-mkdir-config
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-create-config

    # Write config files into config/ subdirectory
    core_toml_path = (config_dir / "core.toml").resolve()
    core_toml_existed = core_toml_path.is_file()
    if core_toml_existed and not args.force:
        actions["core_toml"] = "unchanged"
    else:
        if not args.dry_run:
            toml_utils.dump(desired_core, core_toml_path, header_comment="Cypilot project configuration")
        actions["core_toml"] = "updated" if core_toml_existed else "created"

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-create-config-agents
    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-write-config-agents
    # Write generated AGENTS.md to .gen/ (always overwrite)
    gen_agents_path = (gen_dir / "AGENTS.md").resolve()
    if not args.dry_run:
        gen_agents_path.write_text(gen_agents_content, encoding="utf-8")
    actions["gen_agents"] = "created"

    # Write user-editable AGENTS.md to config/ (preserve existing)
    config_agents_path = (config_dir / "AGENTS.md").resolve()
    config_agents_existed = config_agents_path.is_file()
    if config_agents_existed and not args.force:
        actions["config_agents"] = "unchanged"
    else:
        if not args.dry_run:
            if not config_agents_existed:
                config_agents_path.write_text(
                    "# Custom Agent Navigation Rules\n"
                    "\n"
                    "Add your project-specific WHEN rules here.\n"
                    "These rules are loaded alongside the generated rules in `{cypilot_path}/.gen/AGENTS.md`.\n",
                    encoding="utf-8",
                )
            # If force + existed: leave user content untouched
        actions["config_agents"] = "unchanged" if config_agents_existed else "created"
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-write-config-agents
    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-return-config-agents-path
    actions["gen_agents_path"] = gen_agents_path.as_posix()
    actions["config_agents_path"] = config_agents_path.as_posix()
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config-agents:p1:inst-return-config-agents-path
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-create-config-agents

    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config:p1:inst-validate-schemas
    # Stub: schema validation deferred to p2
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config:p1:inst-validate-schemas

    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config:p1:inst-return-config-paths
    # (paths reported in final JSON output)
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config:p1:inst-return-config-paths

    # @cpt-begin:cpt-cypilot-algo-core-infra-create-config:p1:inst-write-artifacts-toml
    registry_path = (config_dir / "artifacts.toml").resolve()
    registry_existed_before = registry_path.is_file()
    if registry_existed_before and not args.force:
        actions["artifacts_registry"] = "unchanged"
    else:
        if not args.dry_run:
            toml_utils.dump(desired_registry, registry_path, header_comment="Cypilot artifacts registry")
        actions["artifacts_registry"] = "updated" if registry_existed_before else "created"
    # @cpt-end:cpt-cypilot-algo-core-infra-create-config:p1:inst-write-artifacts-toml

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-delegate-kits
    kit_results: Dict[str, Any] = {}
    kits_ref_dir = cypilot_dir / CORE_SUBDIR / "kits"
    config_kits_dir = config_dir / "kits"
    gen_kits_dir = gen_dir / "kits"
    gen_skill_nav_parts: List[str] = []
    if kits_ref_dir.is_dir() and not args.dry_run:
        from ..utils.blueprint import process_kit

        for kit_dir in sorted(kits_ref_dir.iterdir()):
            if not kit_dir.is_dir():
                continue
            bp_dir = kit_dir / "blueprints"
            if not bp_dir.is_dir():
                continue

            kit_slug = kit_dir.name
            user_bp_dir = config_kits_dir / kit_slug / "blueprints"

            # Copy blueprints to config/kits/{slug}/blueprints/ (user-editable)
            if user_bp_dir.exists():
                shutil.rmtree(user_bp_dir)
            user_bp_dir.parent.mkdir(parents=True, exist_ok=True)
            shutil.copytree(bp_dir, user_bp_dir)

            # Generate resources from blueprints into .gen/kits/{slug}/
            summary, kit_errors = process_kit(
                kit_slug, user_bp_dir, gen_kits_dir, dry_run=False,
            )
            kit_results[kit_slug] = {
                "files_written": summary.get("files_written", 0),
                "artifact_kinds": summary.get("artifact_kinds", []),
                "errors": kit_errors,
            }
            if kit_errors:
                errors.extend(
                    {"path": kit_slug, "error": e} for e in kit_errors
                )

            # Write per-kit SKILL.md into .gen/kits/{slug}/SKILL.md
            skill_content = summary.get("skill_content", "")
            if skill_content:
                gen_kit_skill_path = gen_kits_dir / kit_slug / "SKILL.md"
                gen_kit_skill_path.parent.mkdir(parents=True, exist_ok=True)
                gen_kit_skill_path.write_text(
                    f"# Cypilot Skill — Kit `{kit_slug}`\n\n"
                    f"Generated from kit `{kit_slug}` blueprints.\n\n"
                    + skill_content + "\n",
                    encoding="utf-8",
                )
                gen_skill_nav_parts.append(
                    f"ALWAYS open and follow `{{cypilot_path}}/.gen/kits/{kit_slug}/SKILL.md` "
                    f"WHEN working with kit `{kit_slug}` artifacts"
                )
                actions["gen_kit_skill_" + kit_slug] = "created"

            # Append sysprompt content to .gen/AGENTS.md
            sysprompt_content = summary.get("sysprompt_content", "")
            if sysprompt_content:
                gen_agents_text = gen_agents_path.read_text(encoding="utf-8")
                gen_agents_text = gen_agents_text.rstrip() + "\n\n" + sysprompt_content + "\n"
                gen_agents_path.write_text(gen_agents_text, encoding="utf-8")
                actions["gen_agents_sysprompt"] = "injected"

    # Write .gen/SKILL.md — navigation hub routing to per-kit skills
    if not args.dry_run:
        gen_skill_path = gen_dir / "SKILL.md"
        nav_rules = "\n\n".join(gen_skill_nav_parts) if gen_skill_nav_parts else ""
        gen_skill_path.write_text(
            "# Cypilot Generated Skills\n\n"
            "This file routes to per-kit skill instructions.\n\n"
            + (nav_rules + "\n" if nav_rules else ""),
            encoding="utf-8",
        )
        actions["gen_skill"] = "created"

    # Write config/SKILL.md — empty, for user extensions (preserve existing)
    if not args.dry_run:
        config_skill_path = config_dir / "SKILL.md"
        if not config_skill_path.is_file():
            config_skill_path.write_text(
                "# Custom Skill Extensions\n"
                "\n"
                "Add your project-specific skill instructions here.\n"
                "These are loaded alongside the generated skills in `{cypilot_path}/.gen/SKILL.md`.\n",
                encoding="utf-8",
            )
            actions["config_skill"] = "created"
        else:
            actions["config_skill"] = "unchanged"

    actions["kits"] = json.dumps(kit_results)
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-delegate-kits

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-delegate-agents
    # Stub: Agent Generator (Feature 5 boundary) — agent entry points generated separately
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-delegate-agents

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-inject-agents
    root_agents_action = _inject_root_agents(project_root, install_rel, dry_run=args.dry_run)
    actions["root_agents"] = root_agents_action
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-inject-agents

    if errors:
        err_result: Dict[str, object] = {
            "status": "ERROR",
            "message": "Init failed",
            "project_root": project_root.as_posix(),
            "cypilot_dir": cypilot_dir.as_posix(),
            "dry_run": bool(args.dry_run),
            "errors": errors,
        }
        if backups:
            err_result["backups"] = backups
        print(json.dumps(err_result, indent=2, ensure_ascii=False))
        return 1

    # @cpt-begin:cpt-cypilot-flow-core-infra-project-init:p1:inst-return-init-ok
    # @cpt-begin:cpt-cypilot-state-core-infra-project-install:p1:inst-init-complete
    result: Dict[str, object] = {
        "status": "PASS",
        "project_root": project_root.as_posix(),
        "cypilot_dir": cypilot_dir.as_posix(),
        "core_toml": core_toml_path.as_posix(),
        "dry_run": bool(args.dry_run),
        "actions": actions,
        "root_system": root_system,
    }
    if backups:
        result["backups"] = backups
    print(json.dumps(result, indent=2, ensure_ascii=False))
    return 0
    # @cpt-end:cpt-cypilot-state-core-infra-project-install:p1:inst-init-complete
    # @cpt-end:cpt-cypilot-flow-core-infra-project-init:p1:inst-return-init-ok
